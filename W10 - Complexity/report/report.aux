\relax 
\citation{*}
\@writefile{toc}{\contentsline {section}{\numberline {1}Introduction}{2}}
\@writefile{toc}{\contentsline {section}{\numberline {2}Design and Implementation}{2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.1}Generating Lists of Varying Sortedness}{2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2}Quicksort Implementation}{2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3}Generating and Storing Accurate Results of Sortedness and Execution Time}{3}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.3.1}Range and Step Size of Results}{3}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.3.2}Accurately Generating and Storing Results}{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.4}Graphical Analysis}{4}}
\@writefile{toc}{\contentsline {section}{\numberline {3}Results and Conclusion}{4}}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces How the execution time of Quicksort with the rightmost element as the pivot varies with edit distance and array size. Left and right graphs show how execution time varies at the forward sorted and reverse sorted pathological cases respectively. As the sortedness of the arrays decreases, Quicksorts complexity decreases from $O(n^2)$ to $O(nlog(n))$.\relax }}{5}}
\providecommand*\caption@xref[2]{\@setref\relax\@undefined{#1}}
\newlabel{fig:sortedness_vs_time_vs_size}{{1}{5}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces An Alternative view of the surface, showing how the complexity of Quicksort with the rightmost element is a pivot is $O(n^2)$ for sorted and reverse sorted arrays. However, as the edit distance of these arrays increases, the Quicksort algorithm complexity decreases down towards a more optimal complexity of $O(nlog(n))$ and it scales much better as the size of the array increases.\relax }}{6}}
\newlabel{fig:sortedness_vs_time_vs_size}{{2}{6}}
\bibcite{numeric}{1}
\bibcite{numeric}{2}
\bibcite{numeric}{3}
