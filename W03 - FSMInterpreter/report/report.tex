\documentclass{article}

\usepackage{fancyvrb}
\usepackage{graphicx}
\usepackage{float}

\begin{document}

\nocite{*}

\begin{center}
\Huge 
CS2001/CS2101 Week 3 Practical

\vspace{0.5cm}

\textbf{Finite State Machines}

\vspace{1cm}
\LARGE
4th October 2020

\large
\vspace{1.5cm}

\textbf{Matriculation Number: 200002548}

\vspace{0.5cm}

\textbf{Tutor: Alex Konovalov}

\end{center}

\vspace*{3cm}

\tableofcontents

\newpage
\section{Introduction}
The aim of this practical was to create a finite state machine (FSM) interpreter in Java. The interpreter had to construct a FSM by parsing a transition table read in from a text file and then compute the output generated by the FSM from its current state and the input provided. The interpreter had be able to handle multiple different inputs, from the text file describing the FSM and the input string from standard input. The interpreter should output 'Bad description' if the machines description is not well-formed and 'Bad input' if the input characters entered are not part of the set of inputs described in the FSM's description. The interpreter should run with the following command:
\begin{figure}[H]
\centering \begin{BVerbatim}
java fsminterpreter description.fsm < input.txt
\end{BVerbatim}
\end{figure}
\noindent An example of a valid transition table used to describe the FSM is shown below:
\begin{figure}[H]
\centering \begin{BVerbatim}
1 a z 2
1 b y 1
2 a x 3
2 b w 1
3 a v 2
3 b u 3
  ...
\end{BVerbatim}
\end{figure}
\noindent Where the current states, input symbols, output symbols and next states are shown in each column from left to right. States had to be numeric with inputs and outputs composed of single characters. The initial state of the FSM would be the state of the first row in the file. \\ \\ \noindent Following this specification, I successfully built a FSM interpreter in Java. The program handles a variety of different transition tables and checks for errors with the layout of the FSM description, the logic within the FSM and also the string used as input symbols for the FSM. The program is designed to be as intuitive and simple as possible, whilst also having complex functionality to handle different possibilities with regards to the FSM description and input.
\section{Design}
The solution to this practical is split into three classes of which are featured in the UML class diagram in figure \ref{fig:uml}. Overall the practical was designed to be as efficient and maintainable as possible. The data structures used and methods designed below show how this was achieved.
\subsection{FSMInterpreter Class}
As specified, the \verb+fsminterpreter+ class features the main method. This class serves as an interface between the user and the finite state machine behind it. The class receives a path to the FSM description (.fsm file) and an input string from standard input. It then creates a \verb+FiniteStateMachine+, passing in the input string and a \verb+Scanner+ object to read from the FSM description. Therefore this class creates a FSM in an abstract way, with all the details being abstracted from the \verb+FiniteStateMachine+ class. The benefit of this approach is that the interpreter class only has to deal with managing input and not with the inner workings of the FSM.
\begin{figure}[h]
\centering
\includegraphics[width = 340px, clip]{UML_class.png}
\caption{UML class diagram of solution}
\label{fig:uml}
\end{figure}
\subsection{FiniteStateMachine Class}
The \verb+FiniteStateMachine+ class is where most of the logic behind the finite state machines behaviour exists. This class features the \verb+transitions+ hash-table which takes a \verb+StateInputKey, String[]+ key-value pair. This hash-table stores all of the information from the FSM description about the current states, inputs, outputs and next states. The current states and inputs of the FSM are stored as keys within \verb+StateInputKey+ objects and the outputs and next states are the corresponding values. The hash-table was used to store these values rather than arrays or lists because it allows for constant time - O(1) lookups. Therefore because a FSM performs so many lookup operations to fetch the next state and output a result, this will have a huge performance benefit. Furthermore it made implementation easier as an extra unconditional loop was not needed to iterate through an array or list. Hash-tables also automatically remove duplicates and so it made removing lines in the FSM description which were exactly the same, automatic. The \verb+state+ of the FSM is stored as a string. There are also two sets called \verb+uniqueStates+ and \verb+uniqueInputs+ which store all of the unique states and inputs from the FSM description and are key when checking if the next state is a current state and if there is any state-input pairs missing from the FSM description. The \verb+FiniteStateMachine+ class has four methods (not counting the constructor), \verb+load()+, \verb+run()+, \verb+isLayoutValid()+ and \verb+isLogicValid()+.
\subsubsection{The load() method}
The purpose of the \verb+load+ function is to load data from the specified FSM description and store it within the \verb+transitions+ hash-table. This is done by adding a new key-value pair to the hash-table. This key is created by instantiating a new \verb+StateInputKey+ object comprised of the state and input from the current row in the file. However a check is carried out to ensure that the number of symbols per line in the file is equal to four. This is because if the row had any other number of symbols then it is not a valid transition table. This method then sets the value of the FSM's \verb+state+ to the first state present in the FSM description.
\subsubsection{The isLayoutValid() method}
The design of this finite state machine keeps the loading and validating of the FSM description separate. This helps make implementation easier and the code more maintainable. This method iterates through the hash-map, and if either of the current or next states are not represented as numerical values then the method returns \verb+false+. This method checks to see if the length of the \verb+transitions+ hash-map is greater than zero, and if returns \verb+false+. Furthermore if either of the inputs or outputs are made up of strings that are not a character long then the method returns \verb+false+. This is because the specification detailed that inputs and outputs must be single characters. Also if characters were used then the program would crash with \verb+IllegalArgumentException+ and not return \verb+'Bad description'+ when a input or output longer than one character was present in the FSM description.
\subsubsection{The isLogicValid() method}
This method iterates through hash-map again. It first performs a check to see if each next state in the hash-map is equal to a current state. If not another the method returns \verb+false+. The method then checks to see if  there are any missing rows within the transitions table. This is achieved as follows. We take the sets of the current states and inputs and obtain the product of the length of the sets. If the resultant number is greater than the number of transitions then there is a state-input pair missing and so the FSM description is invalid.
\subsubsection{The run() method}
Finally, the last and most important method within the \verb+FiniteStateMachine+ class. The \verb+run()+ method is where the FSM actually runs through the hash-table using the specified input and outputs the results, moving from state to state. The input string is iterated over. If \verb+transitions+ hash-table does not contain a input-state key pair, created with the current state of the machine and input symbol, then the method outputs 'Bad input'. If not then the FSM outputs the relevant output symbol and moves on to the next state. The run() method is designed to output the result from one row of the FSM immediately, rather than waiting for the whole FSM to finish. This is so we can have the correct FSM behaviour. If this was not the case, and a large transition table and large input sequence was entered into the program, then it would take forever for any output to be received.
\subsection{StateInputKey Class}
The \verb+StateInputKey+ class is needed to be able to use a pair of variables as a key to a \verb+HashMap+ as the default Java \verb+HashMap+'s only allow for one variable to be used as a key. The class overrides the \verb+equals()+ and \verb+hashCode()+ methods so that when used within the \verb+HashMap+ the \verb+contains()+ function calculates the right hash values, taking into account the two variables, in order to lookup the values associated with them.
\section{Testing}
The interpreter was tested various ways. Using \verb+stacscheck+ the program was tested with the basic example tests found at \verb+/cs/studres/CS2001/Practicals/+
\verb+W03-FSM/Tests/+ and a more comprehensive set of tests of my own.
\subsection{Basic Stacscheck Tests}
The interpreter was built and ran successfully, completing all eight of the tests, and outputting the expected result. This can be shown in figure \ref{fig:stacscheck_basic}. This shows that the interpreter has some amount of robustness, however more comprehensive testing is needed.
\begin{figure}[h]
\centering
\includegraphics[width = 320px, clip]{stacscheck_basic.png}
\caption{Basic stacscheck tests running successfully}
\label{fig:stacscheck_basic}
\end{figure}
\subsection{Comprehensive Testing using Stacscheck}
There were numerous extreme edge cases the interpreter had to be tested against. Below I have explained what each test case is testing for, what the expected result is, what the actual result was, as well as detailing the inputs provided to the interpreter. \\

\noindent All the tests below were ran with stacscheck and the test files are provided under the \verb+test/+ directory in this assignment. The output of stacscheck is shown below in figure \ref{fig:stacscheck_comp}. All of the tests ran successfully after a reasonable amount of errors and debugging. In its final state, the interpreter produced no errors and is a robust program that follows the specification and is programmed defensively where the specification becomes vague. For instance in Test 11 when no input is supplied the interpreter should not crash and instead produce no output, this was done successfully.
\\ \\ \noindent Furthermore, the program handles dealing with duplicate state/input pairs excellently. If two rows have the same state and input but different outputs and or next states then the interpreter flags that the description is invalid. If however the state and input pairs have the same outputs and next states then the description is still valid and the interpreter correctly produces the intended output.
\begin{figure}[H]
\centering
\includegraphics[width = 320px, clip]{stacscheck_comp.png}
\caption{Comprehensive tests running successfully in stacscheck}
\label{fig:stacscheck_comp}
\end{figure}

\noindent \\ \\ \textbf{Test 01 - Empty FSM Description} \\
\noindent Input: \verb+a+ \\
Expected Result: \verb+Bad description+ \\
Result: \verb+Bad description+ \\
\begin{figure}[H]
\center
\begin{BVerbatim}
  no file...
\end{BVerbatim}
\caption{description.fsm}
\end{figure}
\noindent This is correct behaviour, having no FSM description should flag up to the user that there is something wrong with their FSM description.

\noindent \\ \\ \textbf{Test 02 - FSM Description Only Whitespace} \\
\noindent Input: \verb+a+ \\
Expected Result: \verb+Bad description+ \\
Result: \verb+Bad description+ \\
\begin{figure}[H]
\center
\begin{BVerbatim}
            
\end{BVerbatim}
\caption{description.fsm}
\end{figure}
\noindent Obviously, having a FSM description full of whitespace should be invalid and be flagged to the user.

\noindent \\ \\ \textbf{Test 03 - FSM Description with Whitespace and Characters Interchanged} \\
\noindent Input: \verb+a+ \\
Expected Result: \verb+Bad description+ \\
Result: \verb+Bad description+ \\
\begin{figure}[H]
\center
\begin{BVerbatim}
 1 a h 2
 2 a i 1
\end{BVerbatim}
\caption{description.fsm}
\end{figure}
\noindent This is also an invalid form of an FSM description because the program is looking for characters separated by whitespace, not the other way around.

\noindent \\ \\ \textbf{Test 04 - FSM Description No Spaces} \\
\noindent Input: \verb+a+ \\
Expected Result: \verb+Bad description+ \\
Result: \verb+Bad description+ \\
\begin{figure}[H]
\center
\begin{BVerbatim}
1a2a2a2
2a1a1a1
\end{BVerbatim}
\caption{description.fsm}
\end{figure}
\noindent Without any spaces it is impossible to determine where in the FSM description states, input and output symbols are, therefore this is an invalid description.

\noindent \\ \\ \textbf{Test 05 - FSM Description with Multi-digit States} \\
\noindent Input: \verb+ab+ \\
Expected Result: \verb+hi+ \\
Result: \verb+hi+ \\
\begin{figure}[H]
\center
\begin{BVerbatim}
10 a h 20
10 b r 10
20 b i 10
20 a e 10
\end{BVerbatim}
\caption{description.fsm}
\end{figure}
\noindent Multi-digit states work with the FSM because it has been implemented in with the design to store states as strings rather than characters. Therefore they work just like single-digit states and don't cause any errors anywhere else and so we get a correct result from this test.

\noindent \\ \\ \textbf{Test 06 - FSM Description with Multi and Single Digit States} \\
\noindent Input: \verb+aba+ \\
Expected Result: \verb+zyx+ \\
Result: \verb+zyx+ \\
\begin{figure}[H]
\center
\begin{BVerbatim}
10 a z 20
10 b f 10
20 b y 1
20 a e 10
1 a x 10
1 b e 20
\end{BVerbatim}
\caption{description.fsm}
\end{figure}
\noindent If both single and multi-digit states work on their own then they should both work together. We see this happening in the test above.

\noindent \\ \\ \textbf{Test 07 - FSM Description with States Represented as Characters} \\
\noindent Input: \verb+abc+ \\
Expected Result: \verb+Bad description+ \\
Result: \verb+Bad description+ \\
\begin{figure}[H]
\center
\begin{BVerbatim}
a a z b
b b y c
c c x a
\end{BVerbatim}
\caption{description.fsm}
\end{figure}
\noindent In the specification it was said that states can only be represented numerically and so if states are instead represented as characters the description is invalid.

\noindent \\ \\ \textbf{Test 08 - FSM Description All in the Same State} \\
\noindent Input: \verb+abccd+ \\
Expected Result: \verb+hello+ \\
Result: \verb+hello+ \\
\begin{figure}[H]
\center
\begin{BVerbatim}
1 a h 1
1 b e 1
1 c l 1
1 d o 1
\end{BVerbatim}
\caption{description.fsm}
\end{figure}
\noindent As we can see above the program works if there is only one state within the transition table, this is correct behaviour as having one state is still valid within a FSM.

\noindent \\ \\ \textbf{Test 09 - FSM Description with Unidentified Next State} \\
\noindent Input: \verb+a+ \\
Expected Result: \verb+Bad description+ \\
Result: \verb+Bad description+ \\
\begin{figure}[H]
\center
\begin{BVerbatim}
1 a h 2
2 a i 3
\end{BVerbatim}
\caption{description.fsm}
\end{figure}
\noindent A FSM description with a next state that is not already a state in the transition table is invalid since that next state does not have a entry in the transition table.

\noindent \\ \\ \textbf{Test 10 - FSM Description with Positions of States and Inputs/Outputs Changed} \\
\noindent Input: \verb+a+ \\
Expected Result: \verb+Bad description+ \\
Result: \verb+Bad description+ \\
\begin{figure}[H]
\center
\begin{BVerbatim}
a 1 2 h
b 2 1 e
\end{BVerbatim}
\caption{description.fsm}
\end{figure}
\noindent Obviously changing the columns of states, inputs and outputs causes the FSM description to be invalid since characters may be used to represent numbers for states and the input/output symbols may not match up with next states.

\noindent \\ \\ \textbf{Test 11 - No Input} \\
\noindent Input: \verb++ \\
Expected Result: \verb++ \\
Result: \verb++ \\
\begin{figure}[H]
\center
\begin{BVerbatim}
1 a h 2
2 a i 1
\end{BVerbatim}
\caption{description.fsm}
\end{figure}
\noindent If there is no input into the FSM then the FSM should just do nothing. Therefore the interpreter displays the correct output.

\noindent \\ \\ \textbf{Test 12 - Large Input} \\
\noindent Input: \verb+aaaaaaaaaaaaaaaaaaaa+ \\
Expected Result: \verb+hihihihihihihihihihi+ \\
Result: \verb+hihihihihihihihihihi+ \\
\begin{figure}[H]
\center
\begin{BVerbatim}
1 a h 2
2 a i 1
\end{BVerbatim}
\caption{description.fsm}
\end{figure}
\noindent The FSM should be able to handle a large input just as it would a small one. All that is required is more computing time for searching in the transition table.

\noindent \\ \\ \textbf{Test 13 - FSM Description with Extra Rows} \\
\noindent Input: \verb+aa+ \\
Expected Result: \verb+Bad description+ \\
Result: \verb+Bad description+ \\
\begin{figure}[H]
\center
\begin{BVerbatim}
1 a h 2 a b c d
2 a i 1 a b c d
\end{BVerbatim}
\caption{description.fsm}
\end{figure}
\noindent The specification said that the FSM description must exist at 4 symbols separated by spaces, therefore if more rows are in the description, it should become invalid.

\noindent \\ \\ \textbf{Test 14 - FSM Description with Duplicate State/Input Pair} \\
\noindent Input: \verb+a+ \\
Expected Result: \verb+Bad description+ \\
Result: \verb+Bad description+ \\
\begin{figure}[H]
\center
\begin{BVerbatim}
1 a i 1
1 a x 1
2 b a 2
\end{BVerbatim}
\caption{description.fsm}
\end{figure}
\noindent A FSM description with a duplicate stare/input pair should be invalid since the FSM is non-deterministic since one state and input corresponds to two different outputs and or next states, which is not possible.

\noindent \\ \\ \textbf{Test 15 - FSM Description with Only Exact Duplicate States} \\
\noindent Input: \verb+a+ \\
Expected Result: \verb+i+ \\
Result: \verb+i+ \\
\begin{figure}[H]
\center
\begin{BVerbatim}
1 a i 1
1 a i 1
\end{BVerbatim}
\caption{description.fsm}
\end{figure}
\noindent An FSM description with only exact duplicate states means that the FSM only has one unique row in the transition table and so behaves like a single row. Since a transition table with a single row is valid the FSM runs through this row and outputs the result.

\noindent \\ \\ \textbf{Test 16 - Input not in FSM Description} \\
\noindent Input: \verb+f+ \\
Expected Result: \verb+Bad input+ \\
Result: \verb+Bad input+ \\
\begin{figure}[H]
\center
\begin{BVerbatim}
1 a i 1
1 b x 1
\end{BVerbatim}
\caption{description.fsm}
\end{figure}
\noindent If an input is not featured in the transition table as an input then the input is an invalid input into the FSM as there will be no method to deal with it.

\noindent \\ \\ \textbf{Test 17 - Multi Character Output} \\
\noindent Input: \verb+ab+ \\
Expected Result: \verb+Bad description+ \\
Result: \verb+Bad description+ \\
\begin{figure}[H]
\center
\begin{BVerbatim}
1 a yes 1
1 b no 1
\end{BVerbatim}
\caption{description.fsm}
\end{figure}
\noindent The specification insisted that inputs and outputs be represented as single characters and so the FSM description is invalid because multi character outputs are given.

\noindent \\ \\ \textbf{Test 18 - Sequential FSM Description} \\
\noindent Input: \verb+aaaaaaaaaaaa+ \\
Expected Result: \verb+Hello_World!+ \\
Result: \verb+Hello_World!+ \\
\begin{figure}[H]
\center
\begin{BVerbatim}
1 a H 2
2 a e 3
3 a l 4
4 a l 5
5 a o 6
6 a _ 7
7 a W 8
8 a o 9
9 a r 10
10 a l 11
11 a d 12
12 a ! 1
\end{BVerbatim}
\caption{description.fsm}
\end{figure}
\noindent This was just an interesting test to check on the correct operation of running the FSM with the transition table. The test just requires one input but produces a different character as it move up a state. The interpreter produces the correct result.

\noindent \\ \\ \textbf{Test 19 - One Line FSM Description} \\
\noindent Input: \verb+a+ \\
Expected Result: \verb+i+ \\
Result: \verb+i+ \\
\begin{figure}[H]
\center
\begin{BVerbatim}
1 a i 1
\end{BVerbatim}
\caption{description.fsm}
\end{figure}
\noindent Even though it is a small FSM description it is still valid and is ran by the interpreter.

\noindent \\ \\ \textbf{Test 20 - Exact Duplicate Rows} \\
\noindent Input: \verb+ba+ \\
Expected Result: \verb+hi+ \\
Result: \verb+hi+ \\
\begin{figure}[H]
\center
\begin{BVerbatim}
1 a i 1
1 a i 1
1 b h 1
\end{BVerbatim}
\caption{description.fsm}
\end{figure}
\noindent If two rows in the FSM description are exactly the same then the description is still valid as both rows still produce the same result and move to the same state.

\section{Conclusion}
In this practical I have created a FSM interpreter in Java that has demonstrated to be robust and fit for purpose. As a direct entry student I had never written a Java program before that was more than the \verb+main()+ and one other method. Therefore in this task not only did I learn about the operation of finite state machines, but I developed my programming ability in Java and learnt about the nuances of the language. Many of the features of Java are shared with C++ and so thanks to my knowledge of C++ I could get to grips with the language faster. \\

\noindent I found the difficulty of the practical to be not as harsh as I originally thought. The class structure and methods became clear the more I progressed into the practical. At the start of programming I was storing the transition table as four lists within that \verb+FiniteStateMachine+. However when I learned how to implement hash-tables in Java using \verb+HashMap+'s and the efficiency of constant time lookups I redesigned the whole class around the use of the hash-tables. This made the whole code much easier to read as less unconditional loops were needed to iterate over lists. Furthermore using the \verb+StateInputKey+ class helped me understand more about the function of \verb+HashMap+'s within Java. \\

\noindent Given more time I would like to create another Java program to automatically generate test transition tables to load into the FSM and then link the two together. It would be an interesting thought to have one machine creating the transition tables (using some rules) which then tell another machine how to process inputs in order to generate some output.

\begin{thebibliography}{10}
\bibitem{numeric}
\textit{Java Program to Check if a String is Numeric}, n.d., accessed 28-09-2020, \\\texttt{https://www.programiz.com/java-programming/examples/check-string-numeric}

\bibitem{numeric}
Oracle, \textit{String(Java Platform SE 7)}, n.d., accessed 29-09-2020, \\\texttt{https://docs.oracle.com/javase/7/docs/api/java/lang/String.html}

\bibitem{numeric}
Oracle, \textit{HashSet(Java Platform SE 7)}, n.d., accessed 29-09-2020, \\\texttt{https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html}

\bibitem{numeric}
SudoRahul, \textit{Convert Character to ASCII Numeric Value in Java}, 09-05-2013, accessed 04-10-2020, \\\texttt{https://stackoverflow.com/questions/16458564/convert-character-to-ascii-numeric-value-in-java}

\bibitem{numeric}
karim79, \textit{Iterate Through a HashMap}, 30-07-2009, accessed 04-10-2020, \\\texttt{https://stackoverflow.com/questions/1066589/iterate-through-a-hashmap}

\bibitem{numeric}
Tomasz Nurkiewicz, \textit{How to Create a HashMap with Two Keys (Key-Pair, Value)}, 03-02-2013, accessed 04-10-2020, \\\texttt{https://stackoverflow.com/questions/14677993/how-to-create-a-hashmap-with-two-keys-key-pair-value}
\end{thebibliography}
\end{document}
